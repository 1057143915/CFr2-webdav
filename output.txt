Êñá‰ª∂ÂêçÔºösrc/utils/templates.ts
export function generateHTML(title: string, items: { name: string, href: string }[]): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${title}</title>
          <style>
              body {
                  font-family: Arial, sans-serif;
                  line-height: 1.6;
                  margin: 0;
                  padding: 20px;
                  background-color: #f4f4f4;
              }
              h1 {
                  color: #333;
              }
              .file-list {
                  background-color: white;
                  border-radius: 5px;
                  padding: 20px;
                  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
              }
              .file-item {
                  padding: 10px;
                  border-bottom: 1px solid #eee;
              }
              .file-item:last-child {
                  border-bottom: none;
              }
              .file-item a {
                  color: #0066cc;
                  text-decoration: none;
              }
              .file-item a:hover {
                  text-decoration: underline;
              }
          </style>
      </head>
      <body>
          <h1>${title}</h1>
          <div class="file-list">
              ${items.map(item => `
                  <div class="file-item">
                      <a href="${item.href}">${item.name}</a>
                  </div>
              `).join('')}
          </div>
      </body>
      </html>
    `;
  }
  
  export function generateErrorHTML(title: string, message: string): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${title}</title>
          <style>
              body {
                  font-family: Arial, sans-serif;
                  line-height: 1.6;
                  margin: 0;
                  padding: 20px;
                  background-color: #f4f4f4;
              }
              h1 {
                  color: #333;
              }
              .error-message {
                  background-color: white;
                  border-radius: 5px;
                  padding: 20px;
                  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                  color: #e60000;
              }
          </style>
      </head>
      <body>
          <h1>${title}</h1>
          <div class="error-message">
              ${message}
          </div>
      </body>
      </html>
    `;
  }

Êñá‰ª∂ÂêçÔºösrc/index.ts
import { handleRequest } from './handlers/requestHandler';
import { Env } from './types';

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    return handleRequest(request, env, ctx);
  }
};

Êñá‰ª∂ÂêçÔºösrc/types.ts
export interface Env {
  bucket: R2Bucket;
  USERNAME: string;
  PASSWORD: string;
}

export interface CacheableResponse {
  response: Response;
  expiry: number;
}

Êñá‰ª∂ÂêçÔºösrc/handlers/requestHandler.ts
import { Env } from '../types';
import { handleWebDAV } from './webdavHandler';
import { authenticate } from '../utils/auth';
import { setCORSHeaders } from '../utils/cors';
import { logger } from '../utils/logger';

export async function handleRequest(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
  try {
    if (request.method !== "OPTIONS" && !authenticate(request, env)) {
      return new Response("Unauthorized", {
        status: 401,
        headers: {
          "WWW-Authenticate": 'Basic realm="webdav"'
        }
      });
    }

    const response = await handleWebDAV(request, env.bucket);

    setCORSHeaders(response, request);
    return response;
  } catch (error) {
    logger.error("Error in request handling:", error);
    return new Response("Internal Server Error", { status: 500 });
  }
}

Êñá‰ª∂ÂêçÔºösrc/handlers/webdavHandler.ts
import { listAll, fromR2Object, make_resource_path } from '../utils/webdavUtils';
import { logger } from '../utils/logger';
import { generateHTML, generateErrorHTML } from '../utils/templates';

export async function handleWebDAV(request: Request, bucket: R2Bucket): Promise<Response> {
  const SUPPORT_METHODS = ["OPTIONS", "PROPFIND", "MKCOL", "GET", "HEAD", "PUT", "COPY", "MOVE", "DELETE"];
  const DAV_CLASS = "1";

  try {
    switch (request.method) {
      case "OPTIONS":
        return new Response(null, {
          status: 204,
          headers: {
            Allow: SUPPORT_METHODS.join(", "),
            DAV: DAV_CLASS
          }
        });
      case "HEAD":
        return await handle_head(request, bucket);
      case "GET":
        return await handle_get(request, bucket);
      case "PUT":
        return await handle_put(request, bucket);
      case "DELETE":
        return await handle_delete(request, bucket);
      case "MKCOL":
        return await handle_mkcol(request, bucket);
      case "PROPFIND":
        return await handle_propfind(request, bucket);
      case "COPY":
        return await handle_copy(request, bucket);
      case "MOVE":
        return await handle_move(request, bucket);
      default:
        return new Response("Method Not Allowed", {
          status: 405,
          headers: {
            Allow: SUPPORT_METHODS.join(", "),
            DAV: DAV_CLASS
          }
        });
    }
  } catch (error) {
    logger.error("Error in WebDAV handling:", error);
    return new Response(generateErrorHTML("Internal Server Error", error.message), {
      status: 500,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
}

async function handle_get(request: Request, bucket: R2Bucket): Promise<Response> {
  const resource_path = make_resource_path(request);

  if (request.url.endsWith("/")) {
    // Â§ÑÁêÜÁõÆÂΩï
    let items = [];

    if (resource_path !== "") {
      items.push({ name: "üìÅ ..", href: "../" });
    }

    try {
      for await (const object of listAll(bucket, resource_path)) {
        if (object.key === resource_path) continue;
        const isDirectory = object.customMetadata?.resourcetype === "";
        const displayName = object.key.split('/').pop() || object.key;
        const href = `/${object.key + (isDirectory ? "/" : "")}`;
        items.push({ name: `${isDirectory ? 'üìÅ ' : 'üìÑ '}${displayName}`, href });
      }
    } catch (error) {
      logger.error("Error listing objects:", error);
      return new Response(generateErrorHTML("Error listing directory contents", error.message), {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }

    const page = generateHTML("WebDAV File Browser", items);
    return new Response(page, {
      status: 200,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  } else {
    // Â§ÑÁêÜÊñá‰ª∂
    try {
      const object = await bucket.get(resource_path);
      if (!object) {
        return new Response("Not Found", { status: 404 });
      }
      return new Response(object.body, {
        status: 200,
        headers: {
          "Content-Type": object.httpMetadata?.contentType ?? "application/octet-stream",
          "Content-Length": object.size.toString(),
        }
      });
    } catch (error) {
      logger.error("Error getting object:", error);
      return new Response(generateErrorHTML("Error retrieving file", error.message), {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
  }
}

async function handle_put(request: Request, bucket: R2Bucket): Promise<Response> {
  const resource_path = make_resource_path(request);

  try {
    const body = await request.arrayBuffer();
    await bucket.put(resource_path, body, {
      httpMetadata: {
        contentType: request.headers.get("Content-Type") || "application/octet-stream",
      },
    });
    return new Response("Created", { status: 201 });
  } catch (error) {
    logger.error("Error uploading file:", error);
    return new Response(generateErrorHTML("Error uploading file", error.message), {
      status: 500,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
}

// ÂÆûÁé∞ÂÖ∂‰ªñWebDAVÊñπÊ≥ïÁöÑÂ§ÑÁêÜÂáΩÊï∞Ôºöhandle_head, handle_delete, handle_mkcol, handle_propfind, handle_copy, handle_move
// ...


Êñá‰ª∂ÂêçÔºösrc/utils/auth.ts
import { Env } from '../types';

export function authenticate(request: Request, env: Env): boolean {
  const authHeader = request.headers.get("Authorization");
  const expectedAuth = `Basic ${btoa(`${env.USERNAME}:${env.PASSWORD}`)}`;
  return authHeader === expectedAuth;
}


Êñá‰ª∂ÂêçÔºösrc/utils/cors.ts
export function setCORSHeaders(response: Response, request: Request): void {
  const SUPPORT_METHODS = ["OPTIONS", "PROPFIND", "MKCOL", "GET", "HEAD", "PUT", "COPY", "MOVE", "DELETE"];
  
  response.headers.set("Access-Control-Allow-Origin", request.headers.get("Origin") ?? "*");
  response.headers.set("Access-Control-Allow-Methods", SUPPORT_METHODS.join(", "));
  response.headers.set(
    "Access-Control-Allow-Headers",
    ["authorization", "content-type", "depth", "overwrite", "destination", "range"].join(", ")
  );
  response.headers.set(
    "Access-Control-Expose-Headers",
    ["content-type", "content-length", "dav", "etag", "last-modified", "location", "date", "content-range"].join(", ")
  );
  response.headers.set("Access-Control-Allow-Credentials", "false");
  response.headers.set("Access-Control-Max-Age", "86400");
}

Êñá‰ª∂ÂêçÔºösrc/utils/logger.ts
export const logger = {
  info: (message: string, ...args: any[]) => console.log(`[INFO] ${message}`, ...args),
  error: (message: string, ...args: any[]) => console.error(`[ERROR] ${message}`, ...args),
  warn: (message: string, ...args: any[]) => console.warn(`[WARN] ${message}`, ...args),
};

Êñá‰ª∂ÂêçÔºösrc/utils/webdavUtils.ts
export async function* listAll(bucket: R2Bucket, prefix: string, isRecursive = false) {
  let cursor: string | undefined = undefined;
  do {
    const r2_objects = await bucket.list({
      prefix,
      delimiter: isRecursive ? undefined : "/",
      cursor,
      include: ["httpMetadata", "customMetadata"]
    });
    for (const object of r2_objects.objects) {
      yield object;
    }
    cursor = r2_objects.truncated ? r2_objects.cursor : undefined;
  } while (cursor);
}

export function fromR2Object(object: R2Object | null) {
  if (!object) {
    return {
      creationdate: new Date().toUTCString(),
      displayname: undefined,
      getcontentlanguage: undefined,
      getcontentlength: "0",
      getcontenttype: undefined,
      getetag: undefined,
      getlastmodified: new Date().toUTCString(),
      resourcetype: ""
    };
  }
  return {
    creationdate: object.uploaded.toUTCString(),
    displayname: object.httpMetadata?.contentDisposition,
    getcontentlanguage: object.httpMetadata?.contentLanguage,
    getcontentlength: object.size.toString(),
    getcontenttype: object.httpMetadata?.contentType,
    getetag: object.etag,
    getlastmodified: object.uploaded.toUTCString(),
    resourcetype: object.customMetadata?.resourcetype ?? ""
  };
}

export function make_resource_path(request: Request) {
  let path = new URL(request.url).pathname.slice(1);
  return path.endsWith("/") ? path.slice(0, -1) : path;
}

